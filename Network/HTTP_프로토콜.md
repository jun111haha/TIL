# HTTP 에 대하여
HTTP(Hypertext Transfer Protocol)는 인터넷상에서 데이터를 주고 받기 위한 서버/클라이언트 모델을 따르는 프로토콜 이다. 애플리케이션 레벨의 프로토콜로 TCP/IP위에서 작동한다.
가장 성공적인 인터넷 프로토콜이다. HTTP가 없었다면 인터넷은 지금과는 전혀 다른 모습이였을거다.
HTTP는 어떤 종류의 데이터든지 전송할 수 있도록 설계돼 있다. 인터넷상에서 흔히 볼수 있는 HTML로 작성된 문서는 HTTP로 보낼 수 있는 데이터의 한 종류일 뿐이다. 이미지, 동영상, 오디오, 텍스트 문서들 아무튼 종류를 가리지 않는다.
Transfer라는 해석 그대로 데이터를 전송하겠다라는 의미로 앞에 Hypertext 가 붙은 이유는 하이퍼텍스트 기반으로 데이터를 전송하겠다는. 간단히 말해서 링크기반으로 데이터에 접속하겠다는 의미가 되겠다.

![httpfull](https://github.com/jun111haha/TIL/blob/main/img/http-full-structure.png)

## 작동방식
HTTP는 서버/클라이언트 모델을 따른다. 클라이언트에서 요청(request)를 보내면 서버는 요청을 처리해서 응답(response)한다.
1. 클라이언트 : 서버에 요청하는 클라이언트 소프트웨어가 설치된 컴퓨터. chrom, firefox, ie등의 클라이언트 소프트웨어를 이용한다. 클라이언트는 URI를 이용해서 서버에 접속하고, 데이터를 요청할 수 있다.
2. 서버 : 클라이언트의 요청을 받아서, 요청을 해석하고 응답을 하는 소프트웨어가 설치된 컴퓨터. Apache, nginx, IIS, lighttpd 등이 서버 소프트웨어다.

## Connectless & Stateless
HTTP는 Connectless 방식으로 작동한다 서버에 연결하고, 요청해서 응답을 받으면 연결을 끊어버린다. 기본적으로는 자원 하나에 대해서 하나의 연결을 만든다. 이런 작동방식은 각각 아래의 장점과 단점을 가진다.

장점 : 불특정 다수를 대상으로 하는 서비스에 적합한 방식이다. 수십만명이 웹 서비스를 사용하더라도 접속유지는 최소한으로 할 수 있기 때문에, 더 많은 유저의 요청을 처리할 수 있다.
단점 : 연결을 끊어버리기 때문에, 클라이언트의 이전 상태를 알 수가 없다. 이러한 HTTP의 특징을 stateless라고 하는데, Connectless로 부터 파생되는 특징이라고 할 수 있다. 클라이언트의 이전 상태 정보를 알 수 없게 되면, 웹 서비스를 하는데 당장에 문제가 생긴다. 예컨데, 클라이언트가 과거에 로그인을 성공하더라도 로그 정보를 유지할 수가 없다. HTTP는 cookie를 이용해서 이 문제를 해결하고 있다.

Cookie는 클라이언트와 서버의 상태 정보를 담고 있는 정보조각이다. 로그인을 예로 들자면, 클라이언트가 로그인에 성공하면, 서버는 로그인 정보를 자신의 데이터베이스에 저장하고 동일한 값을 cookie형태로 클라이언트에 보낸다. 클라이언트는 다음 번 요청때 cookie를 서버에 보내는데, 서버는 cookie 값으로 자신의 데이터베이스를 조회해서 로그인 여부를 확인할 수 있다. 자세한 내용은 아래 세션 관리에서 다룬다.

## URI
클라이언트 프로그램(이하 웹 브라우저)은 URI를 이용하여 자원의 위치를 찾는다. URI는 HTTP와는 독립된 다른 체계다. HTTP는 전송 프로토콜이고, URI는 자원의 위치를 알려주기 위한 프로토콜이다. Uniform Resource Identifiers 의 줄임로, World Wide Web 상에서 접근하고자 하는 자원의 위치를 나타내기 위해서 사용한다. 자원은 "문서", "이미지", "동영상", "프로그램", "이메일"등 모든 것이 될 수 있다.

## Method(메서드)
메서드는 요청의 종류를 서버에게 알려주기 위해서 사용한다. 다음은 요청에 사용할 수 있는 메서드들이다.
GET : 정보를 요청하기 위해서 사용한다. (SELECT)
POST : 정보를 밀어넣기 위해서 사용한다. (INSERT)
PUT : 정보를 업데이트하기 위해서 사용한다. (UPDATE)
DELETE : 정보를 삭제하기 위해서 사용한다. (DELETE)
HEAD : (HTTP)헤더 정보만 요청한다. 해당 자원이 존재하는지 혹은 서버에 문제가 없는지를 확인하기 위해서 사용한다.
OPTIONS : 웹서버가 지원하는 메서드의 종류를 요청한다.
TRACE : 클라이언트의 요청을 그대로 반환한다. 예컨데 echo 서비스로 서버 상태를 확인하기 위한 목적으로 주로 사용한다.

보통은 GET, POST, PUT, DELETE 가 주로 사용된다.
- Restful API 서버의 경우에는 GET, POST, DELETE, PUT을 명시적으로 구분한다. 자원의 위치 뿐만 아니라 자원에 할 일 까지 명확히 명시할 수 있기 때문에, Open API 서버를 만들기 위해서 널리 사용한다. 아래는 사용 예다.
GET api.joinc.co.kr/user/list : 유저 목록을 가져온다.
POST api.joinc.co.kr/user/create : 유저를 생성한다. 생성에 필요한 유저 정보는 POST 데이터 형식으로 전달할 수 있다.
PUT api.joinc.co.kr/usr/123 : 유저 ID가 123인 유저의 정보를 업데이트 한다.
DELETE api.joinc.co.kr/user/123 : 유저 ID가 123인 유저를 삭제한다.

## 요청 데이터 포멧
웹 브라우저는 웹 서버에 데이터를 "요청"하는 "클라이언트 프로그램" 이다. 요청은 서버가 인식할 수 있는 약속된 형식(HTTP 형식)을 따라야 한다.
요청 데이터는 "HEADER"와 "BODY"로 구성된다.

## HTTPS
SSL은 전자상거래에서의 데이터 보안을 위해서 개발한 통신 레이어다. SSL은 표현계층의 프로토콜로 응용 계층 아래에 있기 때문에, 어떤 응용 계층의 데이터라도 암호화해서 보낼 수 있다.
HTTP는 기본적으로 평문 데이터 전송을 원칙으로 하기 때문에 개인의 프라이버시가 오가는 서비스들(전자상거래, 전자메일, 사내문서)에 사용하기 힘들다. HTTPS는 SSL 레이어위에 HTTP를 통과 시키는 방식이다. 즉 평문의 HTTP 문서는 SSL 레이어를 통과하면서 암호화 돼서 목적지에 도착하고, 목적지에서는 SSL 레이어를 통과하면서 복호화 돼서 웹 브라우저에 전달된다.

# google.com을 주소창에 친다면?
## DNS 캐시 탐색
1. 브라우저 캐시 체크
- 브라우저는 캐싱된 DNS(Domain Name System) 기록들을 통해 www.google.com 에 대응 되는 IP 주소가 있는지 검색합니다
2. OS 캐쉬 탐색
- 운영체제 안에 있는 systemcall 을 통해 그 내용에 접근하여 찾음
3. 라우터 캐시 확인
- 집에서 사용하는 공유기에서 찾는다 거기서 DNS 탐색을 한다.
4. ISP 캐시 탐색
- 한국에서 인터넷을 제공하는 회사를 생각하면된다

## DNS 로 IP 주소 획득
- ISP 캐시에서까지 ip 주소를 찾을수 없다면 이제 ISP 의 DNS sever 에 DNS 쿼리를 보내야한다. 즉 구글이라는 ip주소 알면 나한테좀 알려줘! 
이를 Revursive search 라고 하는데, 아래의 순서대로 찾는다. 이러한 일은 ISP의 DNS recursor 가 담당하며, 다른 DNS name 서버에다가 물어보는 일을 한다.

![images_doodream_post_3385e8b7-386f-4921-9304-6393fd180573_image](https://user-images.githubusercontent.com/59434443/226158184-ec610f06-2c8f-4ae4-b040-99b3ced83adf.png)

DNS recursor에서 root name server로 연락을 합니다. root name server는 .com 도메인 서버로 접근합니다. .com 도메인 서버는 google.com 도메인 서버로 접근합니다. google.com 네임서버는 www.google.com 에 매칭되는 IP주소를 찾고 DNS recurser로 보내게 됩니다.

이러한 모든 과정은 작은 패킷으로 전달되는 데 이 패킷안에는 DNS query와 DNS recursor의 IP 주소가 포함됩니다. 이러한 패킷이 이동할 때에 Routing table 을 이용하는데 우리가 알고있는 라우터에는 이러한 라우팅 테이블이 있어서 경로 정보를 등록하고 관리해서 최단 경로를 찾을 수 있습니다. 이 패킷들이 중간에 유실되면 request fail error 가 발생하게 됩니다.

## 브라우저와 서버가 TCP 연결 
- 브라우저가 서버의 IP 주소를 받게되면 연결을 시도하는데 웹사이트의 http 연결의 경우에는 일반적으로 TCP 연결을 합니다.
클라이언트와 서버간 데이터 패킷들이 오고가려면 TCP 연결이 이뤄져야 합니다. 3-way handshake 라는 과정에 의해 서버간 신뢰할 수 있는 연결이뤄집니다.

## 브라우저가 웹서버에 HTTP 요청
1. 연결이 되었다면 데이터를 전송합니다. 클라이언트의 브라우저는 HTTP 프로토콜로 GET 요청을 통해 서버에게 www.google.com의 웹페이지 데이터를 요구합니다.
2. 서버가 request를 처리하고 response를 생성합니다.
- 서버는 브라우저로부터 request를 받아 처리합니다. 그리고 response를 생성해서 보내줍니다. request에서는 http 요청을 통해 받아온 다양한 헤더 정보와 데이터들로 요청을 처리하고 response를 생성합니다. 이때 response는 특정한 포멧 (JSON, XML, HTML ) 등으로 작성
3. 서버가 HTTP response를 보냅니다.
- 서버의 response에는 HTTP 프로토콜에 따른 헤더 정보와 데이터들 보냅니다. 이때 status code로 response 상태를 표현합니다.
4. 브라우저가 HTML content를 보여줍니다.
- 이때 Critical Path 과정을 통해서 브라우저가 렌더링과정을 거치게 됩니다. 이렇게 사용자에게 google.com 화면이 보여지게 됩니다. 이때 정적인 파일들은 브라우저에 의해 캐싱이 되어서 해당페이지를 다시 방문할 경우 서버로 부터 다시 데이터를 요청하지 않도록 합니다.
